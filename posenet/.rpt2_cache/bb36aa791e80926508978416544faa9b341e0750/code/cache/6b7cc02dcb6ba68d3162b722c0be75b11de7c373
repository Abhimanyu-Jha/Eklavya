{"code":"import * as tslib_1 from \"tslib\";\r\nimport { toTensorBuffers3D } from '../util';\r\nimport { buildPartWithScoreQueue } from './build_part_with_score_queue';\r\nimport { decodePose } from './decode_pose';\r\nimport { getImageCoords, squaredDistance } from './util';\r\nfunction withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, _a, keypointId) {\r\n    var x = _a.x, y = _a.y;\r\n    return poses.some(function (_a) {\r\n        var keypoints = _a.keypoints;\r\n        var correspondingKeypoint = keypoints[keypointId].position;\r\n        return squaredDistance(y, x, correspondingKeypoint.y, correspondingKeypoint.x) <=\r\n            squaredNmsRadius;\r\n    });\r\n}\r\nfunction getInstanceScore(existingPoses, squaredNmsRadius, instanceKeypoints) {\r\n    var notOverlappedKeypointScores = instanceKeypoints.reduce(function (result, _a, keypointId) {\r\n        var position = _a.position, score = _a.score;\r\n        if (!withinNmsRadiusOfCorrespondingPoint(existingPoses, squaredNmsRadius, position, keypointId)) {\r\n            result += score;\r\n        }\r\n        return result;\r\n    }, 0.0);\r\n    return notOverlappedKeypointScores /= instanceKeypoints.length;\r\n}\r\nvar kLocalMaximumRadius = 1;\r\nexport function decodeMultiplePoses(heatmapScores, offsets, displacementsFwd, displacementsBwd, outputStride, maxPoseDetections, scoreThreshold, nmsRadius) {\r\n    if (scoreThreshold === void 0) { scoreThreshold = 0.5; }\r\n    if (nmsRadius === void 0) { nmsRadius = 20; }\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var poses, _a, scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, queue, squaredNmsRadius, root, rootImageCoords, keypoints, score;\r\n        return tslib_1.__generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    poses = [];\r\n                    return [4, toTensorBuffers3D([heatmapScores, offsets, displacementsFwd, displacementsBwd])];\r\n                case 1:\r\n                    _a = _b.sent(), scoresBuffer = _a[0], offsetsBuffer = _a[1], displacementsFwdBuffer = _a[2], displacementsBwdBuffer = _a[3];\r\n                    queue = buildPartWithScoreQueue(scoreThreshold, kLocalMaximumRadius, scoresBuffer);\r\n                    squaredNmsRadius = nmsRadius * nmsRadius;\r\n                    while (poses.length < maxPoseDetections && !queue.empty()) {\r\n                        root = queue.dequeue();\r\n                        rootImageCoords = getImageCoords(root.part, outputStride, offsetsBuffer);\r\n                        if (withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, rootImageCoords, root.part.id)) {\r\n                            continue;\r\n                        }\r\n                        keypoints = decodePose(root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer, displacementsBwdBuffer);\r\n                        score = getInstanceScore(poses, squaredNmsRadius, keypoints);\r\n                        poses.push({ keypoints: keypoints, score: score });\r\n                    }\r\n                    return [2, poses];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=decode_multiple_poses.js.map","map":"{\"version\":3,\"file\":\"decode_multiple_poses.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/multi_pose/decode_multiple_poses.ts\"],\"names\":[],\"mappings\":\";AAoBA,OAAO,EAAC,iBAAiB,EAAC,MAAM,SAAS,CAAC;AAE1C,OAAO,EAAC,uBAAuB,EAAC,MAAM,+BAA+B,CAAC;AACtE,OAAO,EAAC,UAAU,EAAC,MAAM,eAAe,CAAC;AACzC,OAAO,EAAC,cAAc,EAAE,eAAe,EAAC,MAAM,QAAQ,CAAC;AAEvD,6CACI,KAAa,EAAE,gBAAwB,EAAE,EAA8B,EACvE,UAAkB;QADwB,QAAC,EAAE,QAAC;IAEhD,OAAO,KAAK,CAAC,IAAI,CAAC,UAAC,EAAW;YAAV,wBAAS;QAC3B,IAAM,qBAAqB,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,QAAQ,CAAC;QAC7D,OAAO,eAAe,CACX,CAAC,EAAE,CAAC,EAAE,qBAAqB,CAAC,CAAC,EAAE,qBAAqB,CAAC,CAAC,CAAC;YAC9D,gBAAgB,CAAC;IACvB,CAAC,CAAC,CAAC;AACL,CAAC;AAMD,0BACI,aAAqB,EAAE,gBAAwB,EAC/C,iBAA6B;IAC/B,IAAI,2BAA2B,GAAG,iBAAiB,CAAC,MAAM,CACtD,UAAC,MAAM,EAAE,EAAiB,EAAE,UAAU;YAA5B,sBAAQ,EAAE,gBAAK;QACvB,IAAI,CAAC,mCAAmC,CAChC,aAAa,EAAE,gBAAgB,EAAE,QAAQ,EAAE,UAAU,CAAC,EAAE;YAC9D,MAAM,IAAI,KAAK,CAAC;SACjB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC,EAAE,GAAG,CAAC,CAAC;IAEZ,OAAO,2BAA2B,IAAI,iBAAiB,CAAC,MAAM,CAAC;AACjE,CAAC;AAKD,IAAM,mBAAmB,GAAG,CAAC,CAAC;AAyD9B,MAAM,8BACF,aAA0B,EAAE,OAAoB,EAChD,gBAA6B,EAAE,gBAA6B,EAC5D,YAAoB,EAAE,iBAAyB,EAAE,cAAoB,EACrE,SAAc;IADmC,+BAAA,EAAA,oBAAoB;IACrE,0BAAA,EAAA,cAAc;;;;;;oBACV,KAAK,GAAW,EAAE,CAAC;oBAGrB,WAAM,iBAAiB,CACnB,CAAC,aAAa,EAAE,OAAO,EAAE,gBAAgB,EAAE,gBAAgB,CAAC,CAAC,EAAA;;oBAF/D,KACF,SACiE,EAF9D,YAAY,QAAA,EAAE,aAAa,QAAA,EAAE,sBAAsB,QAAA,EAAE,sBAAsB,QAAA;oBAI5E,KAAK,GAAG,uBAAuB,CACjC,cAAc,EAAE,mBAAmB,EAAE,YAAY,CAAC,CAAC;oBAEjD,gBAAgB,GAAG,SAAS,GAAG,SAAS,CAAC;oBAI/C,OAAO,KAAK,CAAC,MAAM,GAAG,iBAAiB,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE;wBAEnD,IAAI,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC;wBAKvB,eAAe,GACjB,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,YAAY,EAAE,aAAa,CAAC,CAAC;wBAC3D,IAAI,mCAAmC,CAC/B,KAAK,EAAE,gBAAgB,EAAE,eAAe,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;4BAC/D,SAAS;yBACV;wBAGK,SAAS,GAAG,UAAU,CACxB,IAAI,EAAE,YAAY,EAAE,aAAa,EAAE,YAAY,EAAE,sBAAsB,EACvE,sBAAsB,CAAC,CAAC;wBAEtB,KAAK,GAAG,gBAAgB,CAAC,KAAK,EAAE,gBAAgB,EAAE,SAAS,CAAC,CAAC;wBAEnE,KAAK,CAAC,IAAI,CAAC,EAAC,SAAS,WAAA,EAAE,KAAK,OAAA,EAAC,CAAC,CAAC;qBAChC;oBAED,WAAO,KAAK,EAAC;;;;CACd\"}","dts":{"name":"/home/abhimanyu/Eklavya/posenet/multi_pose/decode_multiple_poses.d.ts","text":"import * as tf from '@tensorflow/tfjs';\r\nimport { Pose } from '../types';\r\nexport declare function decodeMultiplePoses(heatmapScores: tf.Tensor3D, offsets: tf.Tensor3D, displacementsFwd: tf.Tensor3D, displacementsBwd: tf.Tensor3D, outputStride: number, maxPoseDetections: number, scoreThreshold?: number, nmsRadius?: number): Promise<Pose[]>;\r\n"}}
