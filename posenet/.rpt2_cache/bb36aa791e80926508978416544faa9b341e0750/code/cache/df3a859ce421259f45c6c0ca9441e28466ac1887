{"code":"import * as tslib_1 from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs';\r\nimport { connectedPartIndices } from './keypoints';\r\nfunction eitherPointDoesntMeetConfidence(a, b, minConfidence) {\r\n    return (a < minConfidence || b < minConfidence);\r\n}\r\nexport function getAdjacentKeyPoints(keypoints, minConfidence) {\r\n    return connectedPartIndices.reduce(function (result, _a) {\r\n        var leftJoint = _a[0], rightJoint = _a[1];\r\n        if (eitherPointDoesntMeetConfidence(keypoints[leftJoint].score, keypoints[rightJoint].score, minConfidence)) {\r\n            return result;\r\n        }\r\n        result.push([keypoints[leftJoint], keypoints[rightJoint]]);\r\n        return result;\r\n    }, []);\r\n}\r\nvar NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\r\nexport function getBoundingBox(keypoints) {\r\n    return keypoints.reduce(function (_a, _b) {\r\n        var maxX = _a.maxX, maxY = _a.maxY, minX = _a.minX, minY = _a.minY;\r\n        var _c = _b.position, x = _c.x, y = _c.y;\r\n        return {\r\n            maxX: Math.max(maxX, x),\r\n            maxY: Math.max(maxY, y),\r\n            minX: Math.min(minX, x),\r\n            minY: Math.min(minY, y)\r\n        };\r\n    }, {\r\n        maxX: NEGATIVE_INFINITY,\r\n        maxY: NEGATIVE_INFINITY,\r\n        minX: POSITIVE_INFINITY,\r\n        minY: POSITIVE_INFINITY\r\n    });\r\n}\r\nexport function getBoundingBoxPoints(keypoints) {\r\n    var _a = getBoundingBox(keypoints), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\r\n    return [\r\n        { x: minX, y: minY }, { x: maxX, y: minY }, { x: maxX, y: maxY },\r\n        { x: minX, y: maxY }\r\n    ];\r\n}\r\nexport function toTensorBuffer(tensor, type) {\r\n    if (type === void 0) { type = 'float32'; }\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var tensorData;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4, tensor.data()];\r\n                case 1:\r\n                    tensorData = _a.sent();\r\n                    return [2, new tf.TensorBuffer(tensor.shape, type, tensorData)];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function toTensorBuffers3D(tensors) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        return tslib_1.__generator(this, function (_a) {\r\n            return [2, Promise.all(tensors.map(function (tensor) { return toTensorBuffer(tensor, 'float32'); }))];\r\n        });\r\n    });\r\n}\r\nexport function scalePose(pose, scaleY, scaleX) {\r\n    return {\r\n        score: pose.score,\r\n        keypoints: pose.keypoints.map(function (_a) {\r\n            var score = _a.score, part = _a.part, position = _a.position;\r\n            return ({\r\n                score: score,\r\n                part: part,\r\n                position: { x: position.x * scaleX, y: position.y * scaleY }\r\n            });\r\n        })\r\n    };\r\n}\r\nexport function scalePoses(poses, scaleY, scaleX) {\r\n    if (scaleX === 1 && scaleY === 1) {\r\n        return poses;\r\n    }\r\n    return poses.map(function (pose) { return scalePose(pose, scaleY, scaleX); });\r\n}\r\nexport function getValidResolution(imageScaleFactor, inputDimension, outputStride) {\r\n    var evenResolution = inputDimension * imageScaleFactor - 1;\r\n    return evenResolution - (evenResolution % outputStride) + 1;\r\n}\r\nexport function getInputTensorDimensions(input) {\r\n    return input instanceof tf.Tensor ? [input.shape[0], input.shape[1]] :\r\n        [input.height, input.width];\r\n}\r\nexport function toInputTensor(input) {\r\n    return input instanceof tf.Tensor ? input : tf.fromPixels(input);\r\n}\r\nexport function toResizedInputTensor(input, resizeHeight, resizeWidth, flipHorizontal) {\r\n    return tf.tidy(function () {\r\n        var imageTensor = toInputTensor(input);\r\n        if (flipHorizontal) {\r\n            return imageTensor.reverse(1).resizeBilinear([resizeHeight, resizeWidth]);\r\n        }\r\n        else {\r\n            return imageTensor.resizeBilinear([resizeHeight, resizeWidth]);\r\n        }\r\n    });\r\n}\r\n//# sourceMappingURL=util.js.map","map":"{\"version\":3,\"file\":\"util.js\",\"sourceRoot\":\"\",\"sources\":[\"src/util.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/abhimanyu/Eklavya/posenet/util.d.ts","text":"import * as tf from '@tensorflow/tfjs';\r\nimport { OutputStride } from './mobilenet';\r\nimport { Keypoint, Pose, PosenetInput, TensorBuffer3D, Vector2D } from './types';\r\nexport declare function getAdjacentKeyPoints(keypoints: Keypoint[], minConfidence: number): Keypoint[][];\r\nexport declare function getBoundingBox(keypoints: Keypoint[]): {\r\n    maxX: number;\r\n    maxY: number;\r\n    minX: number;\r\n    minY: number;\r\n};\r\nexport declare function getBoundingBoxPoints(keypoints: Keypoint[]): Vector2D[];\r\nexport declare function toTensorBuffer<rank extends tf.Rank>(tensor: tf.Tensor<rank>, type?: 'float32' | 'int32'): Promise<tf.TensorBuffer<rank>>;\r\nexport declare function toTensorBuffers3D(tensors: tf.Tensor3D[]): Promise<TensorBuffer3D[]>;\r\nexport declare function scalePose(pose: Pose, scaleY: number, scaleX: number): Pose;\r\nexport declare function scalePoses(poses: Pose[], scaleY: number, scaleX: number): Pose[];\r\nexport declare function getValidResolution(imageScaleFactor: number, inputDimension: number, outputStride: OutputStride): number;\r\nexport declare function getInputTensorDimensions(input: PosenetInput): [number, number];\r\nexport declare function toInputTensor(input: PosenetInput): tf.Tensor<tf.Rank.R3>;\r\nexport declare function toResizedInputTensor(input: PosenetInput, resizeHeight: number, resizeWidth: number, flipHorizontal: boolean): tf.Tensor3D;\r\n"}}
