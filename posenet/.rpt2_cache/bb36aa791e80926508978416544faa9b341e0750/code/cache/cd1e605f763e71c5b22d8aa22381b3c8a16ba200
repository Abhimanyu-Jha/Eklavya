{"code":"import * as tslib_1 from \"tslib\";\r\nimport { partNames } from '../keypoints';\r\nimport { toTensorBuffer } from '../util';\r\nimport { argmax2d } from './argmax2d';\r\nimport { getOffsetPoints, getPointsConfidence } from './util';\r\nexport function decodeSinglePose(heatmapScores, offsets, outputStride) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var totalScore, heatmapValues, _a, scoresBuffer, offsetsBuffer, heatmapValuesBuffer, offsetPoints, offsetPointsBuffer, keypointConfidence, keypoints;\r\n        return tslib_1.__generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    totalScore = 0.0;\r\n                    heatmapValues = argmax2d(heatmapScores);\r\n                    return [4, Promise.all([\r\n                            toTensorBuffer(heatmapScores), toTensorBuffer(offsets),\r\n                            toTensorBuffer(heatmapValues, 'int32')\r\n                        ])];\r\n                case 1:\r\n                    _a = _b.sent(), scoresBuffer = _a[0], offsetsBuffer = _a[1], heatmapValuesBuffer = _a[2];\r\n                    offsetPoints = getOffsetPoints(heatmapValuesBuffer, outputStride, offsetsBuffer);\r\n                    return [4, toTensorBuffer(offsetPoints)];\r\n                case 2:\r\n                    offsetPointsBuffer = _b.sent();\r\n                    keypointConfidence = Array.from(getPointsConfidence(scoresBuffer, heatmapValuesBuffer));\r\n                    keypoints = keypointConfidence.map(function (score, keypointId) {\r\n                        totalScore += score;\r\n                        return {\r\n                            position: {\r\n                                y: offsetPointsBuffer.get(keypointId, 0),\r\n                                x: offsetPointsBuffer.get(keypointId, 1)\r\n                            },\r\n                            part: partNames[keypointId],\r\n                            score: score\r\n                        };\r\n                    });\r\n                    heatmapValues.dispose();\r\n                    offsetPoints.dispose();\r\n                    return [2, { keypoints: keypoints, score: totalScore / keypoints.length }];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=decode_single_pose.js.map","map":"{\"version\":3,\"file\":\"decode_single_pose.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/single_pose/decode_single_pose.ts\"],\"names\":[],\"mappings\":\";AAmBA,OAAO,EAAC,SAAS,EAAC,MAAM,cAAc,CAAC;AAGvC,OAAO,EAAC,cAAc,EAAC,MAAM,SAAS,CAAC;AAEvC,OAAO,EAAC,QAAQ,EAAC,MAAM,YAAY,CAAC;AACpC,OAAO,EAAC,eAAe,EAAE,mBAAmB,EAAC,MAAM,QAAQ,CAAC;AAiC5D,MAAM,2BACF,aAA0B,EAAE,OAAoB,EAChD,YAA0B;;;;;;oBACxB,UAAU,GAAG,GAAG,CAAC;oBAEf,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAC;oBAEa,WAAM,OAAO,CAAC,GAAG,CAAC;4BAC3E,cAAc,CAAC,aAAa,CAAC,EAAE,cAAc,CAAC,OAAO,CAAC;4BACtD,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC;yBACvC,CAAC,EAAA;;oBAHI,KAAqD,SAGzD,EAHK,YAAY,QAAA,EAAE,aAAa,QAAA,EAAE,mBAAmB,QAAA;oBAKjD,YAAY,GACd,eAAe,CAAC,mBAAmB,EAAE,YAAY,EAAE,aAAa,CAAC,CAAC;oBAC3C,WAAM,cAAc,CAAC,YAAY,CAAC,EAAA;;oBAAvD,kBAAkB,GAAG,SAAkC;oBAEvD,kBAAkB,GACpB,KAAK,CAAC,IAAI,CAAC,mBAAmB,CAAC,YAAY,EAAE,mBAAmB,CAAC,CAAC,CAAC;oBAEjE,SAAS,GAAG,kBAAkB,CAAC,GAAG,CAAC,UAAC,KAAK,EAAE,UAAU;wBACzD,UAAU,IAAI,KAAK,CAAC;wBACpB,OAAO;4BACL,QAAQ,EAAE;gCACR,CAAC,EAAE,kBAAkB,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC;gCACxC,CAAC,EAAE,kBAAkB,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC;6BACzC;4BACD,IAAI,EAAE,SAAS,CAAC,UAAU,CAAC;4BAC3B,KAAK,OAAA;yBACN,CAAC;oBACJ,CAAC,CAAC,CAAC;oBAEH,aAAa,CAAC,OAAO,EAAE,CAAC;oBACxB,YAAY,CAAC,OAAO,EAAE,CAAC;oBAEvB,WAAO,EAAC,SAAS,WAAA,EAAE,KAAK,EAAE,UAAU,GAAG,SAAS,CAAC,MAAM,EAAC,EAAC;;;;CAC1D\"}","dts":{"name":"/home/abhimanyu/Eklavya/posenet/single_pose/decode_single_pose.d.ts","text":"import * as tf from '@tensorflow/tfjs';\r\nimport { OutputStride } from '../mobilenet';\r\nimport { Pose } from '../types';\r\nexport declare function decodeSinglePose(heatmapScores: tf.Tensor3D, offsets: tf.Tensor3D, outputStride: OutputStride): Promise<Pose>;\r\n"}}
