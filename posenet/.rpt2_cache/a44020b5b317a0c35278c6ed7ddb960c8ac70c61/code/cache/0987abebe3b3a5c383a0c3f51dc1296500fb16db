{"code":"var _this = this;\r\nimport * as tslib_1 from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs';\r\nimport { CheckpointLoader } from './checkpoint_loader';\r\nimport { checkpoints } from './checkpoints';\r\nimport { assertValidOutputStride, assertValidScaleFactor, MobileNet } from './mobilenet';\r\nimport { ModelWeights } from './model_weights';\r\nimport { decodeMultiplePoses } from './multi_pose/decode_multiple_poses';\r\nimport { decodeSinglePose } from './single_pose/decode_single_pose';\r\nimport { getInputTensorDimensions, getValidResolution, scalePose, scalePoses, toResizedInputTensor } from './util';\r\nvar PoseNet = (function () {\r\n    function PoseNet(mobileNet) {\r\n        this.mobileNet = mobileNet;\r\n    }\r\n    PoseNet.prototype.predictForSinglePose = function (input, outputStride) {\r\n        var _this = this;\r\n        if (outputStride === void 0) { outputStride = 16; }\r\n        assertValidOutputStride(outputStride);\r\n        return tf.tidy(function () {\r\n            var mobileNetOutput = _this.mobileNet.predict(input, outputStride);\r\n            var heatmaps = _this.mobileNet.convToOutput(mobileNetOutput, 'heatmap_2');\r\n            var offsets = _this.mobileNet.convToOutput(mobileNetOutput, 'offset_2');\r\n            return { heatmapScores: heatmaps.sigmoid(), offsets: offsets };\r\n        });\r\n    };\r\n    PoseNet.prototype.predictForMultiPose = function (input, outputStride) {\r\n        var _this = this;\r\n        if (outputStride === void 0) { outputStride = 16; }\r\n        return tf.tidy(function () {\r\n            var mobileNetOutput = _this.mobileNet.predict(input, outputStride);\r\n            var heatmaps = _this.mobileNet.convToOutput(mobileNetOutput, 'heatmap_2');\r\n            var offsets = _this.mobileNet.convToOutput(mobileNetOutput, 'offset_2');\r\n            var displacementFwd = _this.mobileNet.convToOutput(mobileNetOutput, 'displacement_fwd_2');\r\n            var displacementBwd = _this.mobileNet.convToOutput(mobileNetOutput, 'displacement_bwd_2');\r\n            return {\r\n                heatmapScores: heatmaps.sigmoid(),\r\n                offsets: offsets,\r\n                displacementFwd: displacementFwd,\r\n                displacementBwd: displacementBwd\r\n            };\r\n        });\r\n    };\r\n    PoseNet.prototype.estimateSinglePose = function (input, imageScaleFactor, flipHorizontal, outputStride) {\r\n        if (imageScaleFactor === void 0) { imageScaleFactor = 0.5; }\r\n        if (flipHorizontal === void 0) { flipHorizontal = false; }\r\n        if (outputStride === void 0) { outputStride = 16; }\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _a, height, width, resizedHeight, resizedWidth, _b, heatmapScores, offsets, pose, scaleY, scaleX;\r\n            var _this = this;\r\n            return tslib_1.__generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        assertValidOutputStride(outputStride);\r\n                        assertValidScaleFactor(imageScaleFactor);\r\n                        _a = getInputTensorDimensions(input), height = _a[0], width = _a[1];\r\n                        resizedHeight = getValidResolution(imageScaleFactor, height, outputStride);\r\n                        resizedWidth = getValidResolution(imageScaleFactor, width, outputStride);\r\n                        _b = tf.tidy(function () {\r\n                            var inputTensor = toResizedInputTensor(input, resizedHeight, resizedWidth, flipHorizontal);\r\n                            return _this.predictForSinglePose(inputTensor, outputStride);\r\n                        }), heatmapScores = _b.heatmapScores, offsets = _b.offsets;\r\n                        return [4, decodeSinglePose(heatmapScores, offsets, outputStride)];\r\n                    case 1:\r\n                        pose = _c.sent();\r\n                        scaleY = height / resizedHeight;\r\n                        scaleX = width / resizedWidth;\r\n                        heatmapScores.dispose();\r\n                        offsets.dispose();\r\n                        return [2, scalePose(pose, scaleY, scaleX)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    PoseNet.prototype.estimateMultiplePoses = function (input, imageScaleFactor, flipHorizontal, outputStride, maxDetections, scoreThreshold, nmsRadius) {\r\n        if (imageScaleFactor === void 0) { imageScaleFactor = 0.5; }\r\n        if (flipHorizontal === void 0) { flipHorizontal = false; }\r\n        if (outputStride === void 0) { outputStride = 16; }\r\n        if (maxDetections === void 0) { maxDetections = 5; }\r\n        if (scoreThreshold === void 0) { scoreThreshold = .5; }\r\n        if (nmsRadius === void 0) { nmsRadius = 20; }\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _a, height, width, resizedHeight, resizedWidth, _b, heatmapScores, offsets, displacementFwd, displacementBwd, poses, scaleY, scaleX;\r\n            var _this = this;\r\n            return tslib_1.__generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        assertValidOutputStride(outputStride);\r\n                        assertValidScaleFactor(imageScaleFactor);\r\n                        _a = getInputTensorDimensions(input), height = _a[0], width = _a[1];\r\n                        resizedHeight = getValidResolution(imageScaleFactor, height, outputStride);\r\n                        resizedWidth = getValidResolution(imageScaleFactor, width, outputStride);\r\n                        _b = tf.tidy(function () {\r\n                            var inputTensor = toResizedInputTensor(input, resizedHeight, resizedWidth, flipHorizontal);\r\n                            return _this.predictForMultiPose(inputTensor, outputStride);\r\n                        }), heatmapScores = _b.heatmapScores, offsets = _b.offsets, displacementFwd = _b.displacementFwd, displacementBwd = _b.displacementBwd;\r\n                        return [4, decodeMultiplePoses(heatmapScores, offsets, displacementFwd, displacementBwd, outputStride, maxDetections, scoreThreshold, nmsRadius)];\r\n                    case 1:\r\n                        poses = _c.sent();\r\n                        heatmapScores.dispose();\r\n                        offsets.dispose();\r\n                        displacementFwd.dispose();\r\n                        displacementBwd.dispose();\r\n                        scaleY = height / resizedHeight;\r\n                        scaleX = width / resizedWidth;\r\n                        return [2, scalePoses(poses, scaleY, scaleX)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    PoseNet.prototype.dispose = function () {\r\n        this.mobileNet.dispose();\r\n    };\r\n    return PoseNet;\r\n}());\r\nexport { PoseNet };\r\nexport function load(multiplier) {\r\n    if (multiplier === void 0) { multiplier = 1.01; }\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var possibleMultipliers, mobileNet;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (tf == null) {\r\n                        throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please \" +\r\n                            \"also include @tensorflow/tfjs on the page before using this model.\");\r\n                    }\r\n                    possibleMultipliers = Object.keys(checkpoints);\r\n                    tf.util.assert(typeof multiplier === 'number', \"got multiplier type of \" + typeof multiplier + \" when it should be a \" +\r\n                        \"number.\");\r\n                    tf.util.assert(possibleMultipliers.indexOf(multiplier.toString()) >= 0, \"invalid multiplier value of \" + multiplier + \".  No checkpoint exists for that \" +\r\n                        (\"multiplier. Must be one of \" + possibleMultipliers.join(',') + \".\"));\r\n                    return [4, mobilenetLoader.load(multiplier)];\r\n                case 1:\r\n                    mobileNet = _a.sent();\r\n                    return [2, new PoseNet(mobileNet)];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport var mobilenetLoader = {\r\n    load: function (multiplier) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\r\n        var checkpoint, checkpointLoader, variables, weights;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    checkpoint = checkpoints[multiplier];\r\n                    checkpointLoader = new CheckpointLoader(checkpoint.url);\r\n                    return [4, checkpointLoader.getAllVariables()];\r\n                case 1:\r\n                    variables = _a.sent();\r\n                    weights = new ModelWeights(variables);\r\n                    return [2, new MobileNet(weights, checkpoint.architecture)];\r\n            }\r\n        });\r\n    }); },\r\n};\r\n//# sourceMappingURL=posenet_model.js.map","map":"{\"version\":3,\"file\":\"posenet_model.js\",\"sourceRoot\":\"\",\"sources\":[\"src/posenet_model.ts\"],\"names\":[],\"mappings\":\"AAiBA,iBAmRA;;AAnRA,OAAO,KAAK,EAAE,MAAM,kBAAkB,CAAC;AAEvC,OAAO,EAAC,gBAAgB,EAAC,MAAM,qBAAqB,CAAC;AACrD,OAAO,EAAC,WAAW,EAAC,MAAM,eAAe,CAAC;AAC1C,OAAO,EAAC,uBAAuB,EAAE,sBAAsB,EAAE,SAAS,EAAoC,MAAM,aAAa,CAAC;AAC1H,OAAO,EAAC,YAAY,EAAC,MAAM,iBAAiB,CAAC;AAC7C,OAAO,EAAC,mBAAmB,EAAC,MAAM,oCAAoC,CAAC;AACvE,OAAO,EAAC,gBAAgB,EAAC,MAAM,kCAAkC,CAAC;AAElE,OAAO,EAAC,wBAAwB,EAAE,kBAAkB,EAAE,SAAS,EAAE,UAAU,EAAE,oBAAoB,EAAC,MAAM,QAAQ,CAAC;AAIjH;IAGE,iBAAY,SAAoB;QAC9B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAcD,sCAAoB,GAApB,UAAqB,KAAkB,EAAE,YAA+B;QAAxE,iBAaC;QAbwC,6BAAA,EAAA,iBAA+B;QAEtE,uBAAuB,CAAC,YAAY,CAAC,CAAC;QACtC,OAAO,EAAE,CAAC,IAAI,CAAC;YACb,IAAM,eAAe,GAAG,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;YAEpE,IAAM,QAAQ,GACV,KAAI,CAAC,SAAS,CAAC,YAAY,CAAC,eAAe,EAAE,WAAW,CAAC,CAAC;YAE9D,IAAM,OAAO,GAAG,KAAI,CAAC,SAAS,CAAC,YAAY,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;YAEzE,OAAO,EAAC,aAAa,EAAE,QAAQ,CAAC,OAAO,EAAE,EAAE,OAAO,SAAA,EAAC,CAAC;QACtD,CAAC,CAAC,CAAC;IACL,CAAC;IAeD,qCAAmB,GAAnB,UAAoB,KAAkB,EAAE,YAA+B;QAAvE,iBA2BC;QA3BuC,6BAAA,EAAA,iBAA+B;QAMrE,OAAO,EAAE,CAAC,IAAI,CAAC;YACb,IAAM,eAAe,GAAG,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;YAEpE,IAAM,QAAQ,GACV,KAAI,CAAC,SAAS,CAAC,YAAY,CAAC,eAAe,EAAE,WAAW,CAAC,CAAC;YAE9D,IAAM,OAAO,GAAG,KAAI,CAAC,SAAS,CAAC,YAAY,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;YAEzE,IAAM,eAAe,GACjB,KAAI,CAAC,SAAS,CAAC,YAAY,CAAC,eAAe,EAAE,oBAAoB,CAAC,CAAC;YAEvE,IAAM,eAAe,GACjB,KAAI,CAAC,SAAS,CAAC,YAAY,CAAC,eAAe,EAAE,oBAAoB,CAAC,CAAC;YAEvE,OAAO;gBACL,aAAa,EAAE,QAAQ,CAAC,OAAO,EAAE;gBACjC,OAAO,SAAA;gBACP,eAAe,iBAAA;gBACf,eAAe,iBAAA;aAChB,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IA4BK,oCAAkB,GAAxB,UACI,KAAmB,EAAE,gBAAsB,EAAE,cAAsB,EACnE,YAA+B;QADV,iCAAA,EAAA,sBAAsB;QAAE,+BAAA,EAAA,sBAAsB;QACnE,6BAAA,EAAA,iBAA+B;;;;;;;wBACjC,uBAAuB,CAAC,YAAY,CAAC,CAAC;wBACtC,sBAAsB,CAAC,gBAAgB,CAAC,CAAC;wBAEnC,KAAkB,wBAAwB,CAAC,KAAK,CAAC,EAAhD,MAAM,QAAA,EAAE,KAAK,QAAA,CAAoC;wBAElD,aAAa,GACf,kBAAkB,CAAC,gBAAgB,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;wBACzD,YAAY,GACd,kBAAkB,CAAC,gBAAgB,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;wBAExD,KAA2B,EAAE,CAAC,IAAI,CAAC;4BACvC,IAAM,WAAW,GAAG,oBAAoB,CACpC,KAAK,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;4BAExD,OAAO,KAAI,CAAC,oBAAoB,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;wBAC9D,CAAC,CAAC,EALK,aAAa,mBAAA,EAAE,OAAO,aAAA,CAK1B;wBAEU,WAAM,gBAAgB,CAAC,aAAa,EAAE,OAAO,EAAE,YAAY,CAAC,EAAA;;wBAAnE,IAAI,GAAG,SAA4D;wBAEnE,MAAM,GAAG,MAAM,GAAG,aAAa,CAAC;wBAChC,MAAM,GAAG,KAAK,GAAG,YAAY,CAAC;wBAEpC,aAAa,CAAC,OAAO,EAAE,CAAC;wBACxB,OAAO,CAAC,OAAO,EAAE,CAAC;wBAElB,WAAO,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,EAAC;;;;KACxC;IAyCK,uCAAqB,GAA3B,UACI,KAAmB,EAAE,gBAAsB,EAAE,cAAsB,EACnE,YAA+B,EAAE,aAAiB,EAAE,cAAmB,EACvE,SAAc;QAFO,iCAAA,EAAA,sBAAsB;QAAE,+BAAA,EAAA,sBAAsB;QACnE,6BAAA,EAAA,iBAA+B;QAAE,8BAAA,EAAA,iBAAiB;QAAE,+BAAA,EAAA,mBAAmB;QACvE,0BAAA,EAAA,cAAc;;;;;;;wBAChB,uBAAuB,CAAC,YAAY,CAAC,CAAC;wBACtC,sBAAsB,CAAC,gBAAgB,CAAC,CAAC;wBAEnC,KAAkB,wBAAwB,CAAC,KAAK,CAAC,EAAhD,MAAM,QAAA,EAAE,KAAK,QAAA,CAAoC;wBAClD,aAAa,GACf,kBAAkB,CAAC,gBAAgB,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;wBACzD,YAAY,GACd,kBAAkB,CAAC,gBAAgB,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;wBAExD,KACF,EAAE,CAAC,IAAI,CAAC;4BACN,IAAM,WAAW,GAAG,oBAAoB,CACpC,KAAK,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;4BACxD,OAAO,KAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;wBAC7D,CAAC,CAAC,EALC,aAAa,mBAAA,EAAE,OAAO,aAAA,EAAE,eAAe,qBAAA,EAAE,eAAe,qBAAA,CAKxD;wBAEO,WAAM,mBAAmB,CACnC,aAAa,EAAE,OAAO,EAAE,eAAe,EAAE,eAAe,EAAE,YAAY,EACtE,aAAa,EAAE,cAAc,EAAE,SAAS,CAAC,EAAA;;wBAFvC,KAAK,GAAG,SAE+B;wBAE7C,aAAa,CAAC,OAAO,EAAE,CAAC;wBACxB,OAAO,CAAC,OAAO,EAAE,CAAC;wBAClB,eAAe,CAAC,OAAO,EAAE,CAAC;wBAC1B,eAAe,CAAC,OAAO,EAAE,CAAC;wBAEpB,MAAM,GAAG,MAAM,GAAG,aAAa,CAAC;wBAChC,MAAM,GAAG,KAAK,GAAG,YAAY,CAAC;wBAEpC,WAAO,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,EAAC;;;;KAC1C;IAEM,yBAAO,GAAd;QACE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IACH,cAAC;AAAD,CAAC,AAlND,IAkNC;;AAcD,MAAM,eAAqB,UAAsC;IAAtC,2BAAA,EAAA,iBAAsC;;;;;;oBAE/D,IAAI,EAAE,IAAI,IAAI,EAAE;wBACd,MAAM,IAAI,KAAK,CACX,qEAAqE;4BACrE,oEAAoE,CAAC,CAAC;qBAC3E;oBAEK,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;oBACrD,EAAE,CAAC,IAAI,CAAC,MAAM,CACV,OAAO,UAAU,KAAK,QAAQ,EAC9B,4BAA0B,OAAO,UAAU,0BAAuB;wBAC9D,SAAS,CAAC,CAAC;oBAEnB,EAAE,CAAC,IAAI,CAAC,MAAM,CACV,mBAAmB,CAAC,OAAO,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,EACvD,iCACI,UAAU,sCAAmC;yBAC7C,gCAA8B,mBAAmB,CAAC,IAAI,CAAC,GAAG,CAAC,MAAG,CAAA,CAAC,CAAC;oBAE3C,WAAM,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,EAAA;;oBAA7D,SAAS,GAAc,SAAsC;oBAEnE,WAAO,IAAI,OAAO,CAAC,SAAS,CAAC,EAAC;;;;CAC/B;AAED,MAAM,CAAC,IAAM,eAAe,GAAG;IAC7B,IAAI,EAAE,UAAM,UAA+B;;;;;oBACnC,UAAU,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC;oBAErC,gBAAgB,GAAG,IAAI,gBAAgB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;oBAE5C,WAAM,gBAAgB,CAAC,eAAe,EAAE,EAAA;;oBAApD,SAAS,GAAG,SAAwC;oBAEpD,OAAO,GAAG,IAAI,YAAY,CAAC,SAAS,CAAC,CAAC;oBAE5C,WAAO,IAAI,SAAS,CAAC,OAAO,EAAE,UAAU,CAAC,YAAY,CAAC,EAAC;;;SACxD;CACF,CAAC\"}","dts":{"name":"/home/abhimanyu/Eklavya/posenet/posenet_model.d.ts","text":"import * as tf from '@tensorflow/tfjs';\r\nimport { MobileNet, MobileNetMultiplier, OutputStride } from './mobilenet';\r\nimport { Pose, PosenetInput } from './types';\r\nexport declare type PoseNetResolution = 161 | 193 | 257 | 289 | 321 | 353 | 385 | 417 | 449 | 481 | 513;\r\nexport declare class PoseNet {\r\n    mobileNet: MobileNet;\r\n    constructor(mobileNet: MobileNet);\r\n    predictForSinglePose(input: tf.Tensor3D, outputStride?: OutputStride): {\r\n        heatmapScores: tf.Tensor3D;\r\n        offsets: tf.Tensor3D;\r\n    };\r\n    predictForMultiPose(input: tf.Tensor3D, outputStride?: OutputStride): {\r\n        heatmapScores: tf.Tensor3D;\r\n        offsets: tf.Tensor3D;\r\n        displacementFwd: tf.Tensor3D;\r\n        displacementBwd: tf.Tensor3D;\r\n    };\r\n    estimateSinglePose(input: PosenetInput, imageScaleFactor?: number, flipHorizontal?: boolean, outputStride?: OutputStride): Promise<Pose>;\r\n    estimateMultiplePoses(input: PosenetInput, imageScaleFactor?: number, flipHorizontal?: boolean, outputStride?: OutputStride, maxDetections?: number, scoreThreshold?: number, nmsRadius?: number): Promise<Pose[]>;\r\n    dispose(): void;\r\n}\r\nexport declare function load(multiplier?: MobileNetMultiplier): Promise<PoseNet>;\r\nexport declare const mobilenetLoader: {\r\n    load: (multiplier: MobileNetMultiplier) => Promise<MobileNet>;\r\n};\r\n"}}
